import teachnet.algorithm.BasicAlgorithm;

import java.awt.Color;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Random;
import java.util.ArrayList;
import java.util.List;

import javax.swing.plaf.SliderUI;

public class MyAlgorithm extends BasicAlgorithm{
	Color color = null;
	String caption;
	int id =0;
	int nfaulty=0;
	boolean imfaulty = false;
	boolean initiator = false;
	int message=0;
	int totalmessage, totalnode, value;
	List<MyMsg> messagesrecived;

	public void setup(java.util.Map<String, Object> config){
		id = (Integer) config.get("node.id");
		//the number of faulty node
		nfaulty = (Integer) config.get("faulty");
		caption = "" + id;
		//An ArrayList contains all the massage received
		messagesrecived = new ArrayList<MyMsg>();
		//the number of node in the network (using checkinterface() a random node return a different value)
		totalnode=(Integer) config.get("sizenet");
		
		//how many message a node should receive
		totalmessage=TotalMessageCount();
		
		//the faulty nodes in the network
		String faultynode = (String) config.get("faultynodes");
		String[] faultynodeArray = faultynode.split(",");
		
		for (int i = 0; i < faultynodeArray.length; i++) {	
			if (Integer.parseInt(faultynodeArray[i]) == id) {
				imfaulty=true;
				color=Color.RED;
			}
		}

	}

	public void initiate(){
		initiator=true;
		om(imfaulty,0,new int[] { id });
		
	}

	//Function to send message to other nodes
	public void om(Boolean imfaulty,int message,int[] prevpath){    	
		for (int i = 0; i < checkInterfaces(); i++) {   
			if(imfaulty){
				//If the node is faulty change the message with probability 0.5
				message=new Random().nextInt(2);
			}
			//The message is sent to all the node except for those that are  already in the message's path
			if (!contains(prevpath,i))                 
                            send(i, new MyMsg(prevpath, message, imfaulty));                      
                    }
        }    

	public void receive(int interf, Object message){

			MyMsg receivedMsg = (MyMsg) message;
			// save message received to list
			messagesrecived.add(receivedMsg);
		
			int[] oldPath = receivedMsg.getIdPath();

			//send the new message only if the length of the path is <= to the number of faulty node
			if (oldPath.length <= nfaulty) {
				// construct newPath from oldPath + this node's id for the next message
				int[] newPath = new int[oldPath.length + 1];
				System.arraycopy(oldPath, 0, newPath, 0, oldPath.length);
				newPath[newPath.length - 1] = this.id;

				int messToSend = receivedMsg.getValue();				
				om(imfaulty,messToSend,newPath);

			} else {
				//if the node has received all the message build majorityTree (initiator do not receive any message)
				if (messagesrecived.size() == (totalmessage/(totalnode-1))) {
					buildTree();
				}
			}
			
		}
	
	// Build the majority tree
	private void buildTree() {
		//take the shortest path.
		MyMsg shortestPathMsg = MsgWithShortestPath();
		
		//from the shortest path start to build the majority tree recursively
		buildMajorityRecursively(shortestPathMsg);
		
		//get the calculated value from the root path
		value = shortestPathMsg.getMajority();
		
		caption =id+ " Value:" + value;
		
	}
	
	//take the shortest path received by the node.
	MyMsg MsgWithShortestPath() {
		int minLength = Integer.MAX_VALUE;
		MyMsg shortestPathMsg = null;
		for (MyMsg msg : messagesrecived) {
			if (msg.getIdPath().length < minLength) {
				shortestPathMsg = msg;
				minLength = msg.getIdPath().length;
			}
		}
		return shortestPathMsg;
	}	

	private void buildMajorityRecursively(MyMsg message) {

		buildParents(message);
		
		//if is not a leaf path
		if (message.getChildren().size() > 0) {
			int zeroCount = 0, oneCount = 0;
			
			//for every path generated by this path
			for (MyMsg msg : message.getChildren()) {
				// take the path parent
				buildMajorityRecursively(msg);
				// compute the majority for every path generated by this path
				if (msg.getMajority()==0) {
					zeroCount++;
				} else {
					oneCount++;
				}
			}
			//consider also the value of the path
			if (message.getValue()==0) {
				zeroCount++;
			} else {
				oneCount++;
			}
			
			//set the majority value of this path. if count is equal just take the value of the path
			if(zeroCount>oneCount)
				message.setMajority(0);
			else if (zeroCount<oneCount)
				message.setMajority(1);
			else
				message.setMajority(message.getValue());

		} else {
			//if is a leaf path the majority is just is value
			message.setMajority(message.getValue());
		}
	}

	private void buildParents(MyMsg parentMessage) {
		for (MyMsg msg : messagesrecived) {
			//if the message received by a node have length= msn.length+1 this message can be a child
			if (msg.getIdPath().length == parentMessage.getIdPath().length + 1) {
				//if the parent path already contains the path child break
				if (parentMessage.containsChild(msg)) {
					break;
				}
				boolean isParent = true;
				//if every element of the path is equals so the message is a child of the parentMessage
				for (int i = 0; i < parentMessage.getIdPath().length; i++) {
					if (parentMessage.getIdPath()[i] != msg.getIdPath()[i]) {
						isParent = false;
						break;
					}
				}
				if (isParent) {
					parentMessage.addChild(msg);
				}
			}
		}
	}
		
	// Utility

		//Function to check if inside an array there is a value
		boolean contains(int[] array, int value) {
			for (int arrValue : array) {
				if (arrValue == value)
					return true;
			}
			return false;
		}
		
		//Function to calculate the total number of message
		int TotalMessageCount() {
			int sum = 0;
			for (int i = 0; i <= nfaulty; i++) {
				sum += (totalnode - 1 - i) * factorial(totalnode - 1)/ factorial(totalnode - 1 - i);
			}
			return sum;
		}

		//Function in order to compute the factorial
		private int factorial(int n) {
			int factorial = 1;
			if (n == 0 || n == 1) {
				return factorial;
			}	
			for (int i = 1; i <= n; i++) {
				factorial *= i;
			}
			return factorial;
		}
	}
